<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Bot SMC avec graphique TradingView</title>
<!-- Librairie lightweight-charts -->
<script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
<style>
body {
  margin: 0; font-family: 'Inter', sans-serif; background:#121212; color:#ddd;
  display:flex; flex-direction:column; min-height:100vh;
}
h1 { text-align:center; margin:20px 0; font-size:2rem; }
#prix { text-align:center; font-size:2.5rem; margin:10px 0; font-weight:700; color:#66ff66; }
#graph-container { display:flex; justify-content:center; margin-bottom:20px; }
#chart { max-width: 800px; width: 100%; height: 400px; border-radius:10px; overflow:hidden; }
#dashboard { display:flex; flex-wrap:wrap; justify-content:space-around; padding:10px 20px;}
.card { background:#222; padding:15px; margin:10px; border-radius:10px; width:280px; box-shadow:0 2px 8px rgba(0,0,0,0.5);}
.card h3 { margin-top:0; font-size:1.2rem; margin-bottom:10px; color:#66ff66; }
.kpi { font-size:1rem; font-weight:600; margin:5px 0; display:flex; justify-content:space-between; }
.kpi span { font-weight:700; }
.green { color:#00c853; }
.red { color:#d50000; }
</style>
</head>
<body>

<h1>Bot SMC + Graphique TradingView Style</h1>
<div id="prix">Chargement...</div>
<div id="graph-container">
  <div id="chart"></div>
</div>
<div id="dashboard">
  <!-- Analyse M15 -->
  <div class="card">
    <h3>Analyse M15</h3>
    <div class="kpi">Tendance : <span id="trend-m15" class="neutral">-</span></div>
    <div class="kpi">Structure : <span id="structure-m15">-</span></div>
  </div>
  <!-- Sweep M1 -->
  <div class="card">
    <h3>Sweep M1</h3>
    <div class="kpi">Statut : <span id="sweep-status" class="neutral">-</span></div>
    <div class="kpi">Type : <span id="sweep-type">-</span></div>
  </div>
  <!-- Signal et niveaux -->
  <div class="card">
    <h3>Signal</h3>
    <div class="kpi">Direction : <span id="signal-direction" class="neutral">-</span></div>
    <div class="kpi">Entry : <span id="signal-entry">-</span></div>
    <div class="kpi">SL : <span id="signal-sl" class="red">-</span></div>
    <div class="kpi">TP1 : <span id="signal-tp1">-</span></div>
    <div class="kpi">TP2 : <span id="signal-tp2">-</span></div>
  </div>
</div>

<script>
const chartContainer = document.getElementById('chart');
const priceEl = document.getElementById('prix');
// Analyse graphique
const chart = LightweightCharts.createChart(chartContainer, {
  width: chartContainer.clientWidth,
  height: 400,
  layout: { backgroundColor:'#121212', textColor:'#eee' },
  grid: { vertLines:{color:'#333'}, horzLines:{color:'#333'} },
  crosshair: { mode:1 },
  rightPriceScale: { borderColor:'#555' },
  timeScale: { borderColor:'#555', timeVisible:true, secondsVisible:false }
});
const candleSeries = chart.addCandlestickSeries({
  upColor:'#00ff99', downColor:'#ff0033', borderColor:'#ffffff', wickUpColor:'#00ff99', wickDownColor:'#ff0033',
});
// Buffer candles
let candles = [];
const maxCandles=200;

// Charger historique initial (à partir de Binance)
fetch('https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1m&limit=150')
.then(r=>r.json())
.then(data=> {
  candles = data.map(c => ({ time: Math.floor(c[0]/1000), open: +c[1], high: +c[2], low: +c[3], close: +c[4] }));
  candleSeries.setData(candles);
})
// WebSocket live Binance
const ws=new WebSocket('wss://stream.binance.com:9443/ws/btcusdt@kline_1m');
ws.onmessage=ev => {
  const d=JSON.parse(ev.data);
  const k = d.k;
  if(!k || !k.t) return;
  const c = { time: Math.floor(k.t/1000), open: +k.o, high: +k.h, low: +k.l, close: +k.c };
  if(candles.length && c.time===candles[candles.length-1].time) candles[candles.length-1]=c;
  else { candles.push(c); if(candles.length>maxCandles) candles.shift(); }
  candleSeries.setData(candles);
  
  // Analyse détectée
  updateAnalysis();
};
ws.onerror=()=>{ alert("Erreur WebSocket – Vérifiez votre réseau"); };

// Fonctions d’analyse SMC
function getStructure(c) {
  let s=[];
  for(let i=1; i<c.length; i++) {
    let p=c[i-1], curr=c[i];
    if(curr.high>p.high && curr.low>p.low) s.push('HH');
    else if(curr.low>p.low && curr.high<p.high) s.push('HL');
    else if(curr.high<p.high && curr.low<p.low) s.push('LL');
    else if(curr.high<p.high && curr.low>p.low) s.push('LH');
    else s.push('N');
  }
  return s;
}

function detectTrend(c) {
  if(c.length<3) return 'neutre';
  const s=getStructure(c);
  const last=s[s.length-1], prev=s[s.length-2], prev2=s[s.length-3];
  if(prev2==='HL'&&prev==='HH'&&last==='HH') return 'bullish';
  if(prev2==='LH'&&prev==='LL'&&last==='LL') return 'bearish';
  if(last==='HL'&&prev==='LH') return 'bullish';
  if(last==='LH'&&prev==='HL') return 'bearish';
  return 'neutre';
}

function detectSweep(c, lookback=5) {
  if(c.length<lookback+1) return null;
  const last=c[c.length-1], recent=c.slice(-lookback-1,-1);
  const highs=recent.map(x=>x.high), lows=recent.map(x=>x.low);
  if(last.high>Math.max(...highs)) return {type:'buy-side', price:last.high};
  if(last.low<Math.min(...lows)) return {type:'sell-side', price:last.low};
  return null;
}

// Mise à jour analyse et UI
function updateAnalysis() {
  // Tendance M15 (calcul simple basé sur les derniers candles M15)
  const candlesM15 = candles.slice(-15); 
  const trend=getTrend(candlesM15);
  document.getElementById('trend-m15').textContent=trend;
  document.getElementById('trend-m15').className='kpi '+(trend==='bullish'?'green':(trend==='bearish'?'red':'neutral'));
  // Structure M15
  const structure=getStructure(candlesM15);
  document.getElementById('structure-m15').textContent=structure.slice(-1)[0]||'-';

  // Sweep M1
  const sweep=detectSweep(candles);
  if(sweep) {
    document.getElementById('sweep-status').innerHTML='<span style="color:#00c853;">Nouveau sweep</span>';
    document.getElementById('sweep-type').textContent=sweep.type;
  } else {
    document.getElementById('sweep-status').textContent='En attente';
    document.getElementById('sweep-type').textContent='-';
  }

  // Signaux
  let direction=null;
  if(trend==='bullish' && sweep?.type==='sell-side') direction='long';
  if(trend==='bearish' && sweep?.type==='buy-side') direction='short';
  if(!direction){
    document.getElementById('signal').textContent='Aucun signal détecté';
    ['signal-direction','signal-entry','signal-sl','signal-tp1','signal-tp2'].forEach(id=> {
      document.getElementById(id).textContent='-';
      document.getElementById(id).className='kpi';
    });
    return;
  }

  // Obtenir prix actuel
  const obPrice= candles[candles.length-1]?.close ||0;
  const poolPrice=detectLiquidityPool(candles, direction);
  const levels=calcTradeLevels(direction, sweep.price, obPrice,poolPrice);
  
  document.getElementById('signal-direction').textContent=direction;
  document.getElementById('signal-direction').className='kpi '+(direction==='long'?'green':'red');
  document.getElementById('signal-entry').textContent=levels.entry;
  document.getElementById('signal-sl').textContent=levels.sl;
  document.getElementById('signal-tp1').textContent=levels.tp1;
  document.getElementById('signal-tp2').textContent=levels.tp2;
}

// Calcul niveaux trade
function calcTradeLevels(direction,sweepPrice,obPrice,poolPrice, riskPct=0.5, rr=1) {
  const slBuffer=sweepPrice * (riskPct/100);
  let sl, tp1;
  if(direction==='short'){ sl=sweepPrice+slBuffer; tp1=obPrice-(sl-obPrice)*rr; }
  else { sl=sweepPrice-slBuffer; tp1=obPrice+(obPrice-sl)*rr; }
  return {entry:obPrice.toFixed(2), sl:sl.toFixed(2), tp1:tp1.toFixed(2), tp2:poolPrice.toFixed(2)};
}

function getTrend(c) {
  if(c.length<3) return 'neutre';
  const s=getStructure(c);
  const last=s[s.length-1], prev=s[s.length-2], prev2=s[s.length-3];
  if(prev2==='HL'&&prev==='HH'&&last==='HH') return 'bullish';
  if(prev2==='LH'&&prev==='LL'&&last==='LL') return 'bearish';
  if(last==='HL'&&prev==='LH') return 'bullish';
  if(last==='LH'&&prev==='HL') return 'bearish';
  return 'neutre';
}

// Détecter liquidity pool
function detectLiquidityPool(c, dir) {
  const highs=c.slice(-20).map(x=>x.high);
  const lows=c.slice(-20).map(x=>x.low);
  return dir==='short' ? Math.min(...lows) : Math.max(...highs);
}

// WebSocket pour prix et candles
const socket=new WebSocket('wss://stream.binance.com:9443/ws/btcusdt@kline_1m');
socket.onopen=()=>{ document.getElementById('prix').textContent='Chargement...'; }
socket.onmessage=ev => {
  const d=JSON.parse(ev.data);
  const k=d.k;
  if(!k || !k.t) return;
  const c={ time: Math.floor(k.t/1000), open:+k.o, high:+k.h, low:+k.l, close:+k.c };
  if(candles.length && c.time===candles[candles.length-1].time) candles[candles.length-1]=c;
  else { candles.push(c); if(candles.length>200) candles.shift(); }
  // mettre à jour graphique
  if(candles.length) {
    candleSeries.setData(candles);
    // Analyse automatique
    updateAnalysis();
    // Mise à jour prix
    document.getElementById('prix').textContent=c.close.toFixed(2)+' $';
  }
};
</script>

</body>
</html>
