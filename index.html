<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Bot SMC BTC/USDT Prix en Direct - Bitget</title>
  <style>
    body {
      background: #111;
      color: #eee;
      font-family: Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      margin: 0;
      padding: 20px;
    }
    .container {
      background: #222;
      border-radius: 8px;
      padding: 25px 40px;
      box-shadow: 0 2px 12px #000;
      max-width: 700px;
      width: 100%;
    }
    h1 {
      font-weight: 700;
      margin-bottom: 18px;
      color: #33ff66;
      text-align: center;
    }
    #price {
      font-size: 3em;
      font-weight: 700;
      text-align: center;
      margin-bottom: 15px;
      color: #33ff66;
      font-feature-settings: "tnum";
      font-variant-numeric: tabular-nums;
    }
    #status {
      color: orange;
      text-align: center;
      font-size: 1.1em;
      margin-bottom: 30px;
    }
    #smc-log {
      background: #111;
      border: 1px solid #333;
      padding: 15px;
      height: 250px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 14px;
      white-space: pre-wrap;
      border-radius: 6px;
      margin-bottom: 20px;
    }
    #signal-panel {
      background: #333;
      padding: 20px;
      border-radius: 8px;
      color: #ccc;
      font-family: Arial, sans-serif;
    }
    #signal-panel h2 {
      color: #33ff66;
      margin-bottom: 10px;
    }
    .signal-row {
      display: flex;
      justify-content: space-between;
      padding: 5px 10px;
      margin-bottom: 8px;
      background: #222;
      border-radius: 4px;
    }
    .signal-label {
      font-weight: bold;
      color: #aaa;
    }
    .signal-value {
      font-weight: 700;
      color: #33ff66;
    }
    .signal-value.red {
      color: #ff5555;
    }
  </style>
</head>
<body>

  <div class="container">
    <h1>Bot SMC BTC/USDT <br>Prix en Direct (Bitget)</h1>
    <div id="price">Chargement...</div>
    <div id="status">Connexion au flux WebSocket ...</div>

    <div id="smc-log">Logs SMC en temps réel...</div>

    <div id="signal-panel" style="display:none;">
      <h2>Signal SMC</h2>
      <div class="signal-row"><div class="signal-label">Tendance M15</div><div id="trend-m15" class="signal-value"></div></div>
      <div class="signal-row"><div class="signal-label">Type Sweep M1</div><div id="sweep-type" class="signal-value"></div></div>
      <div class="signal-row"><div class="signal-label">Prix Sweep</div><div id="sweep-price" class="signal-value"></div></div>
      <div class="signal-row"><div class="signal-label">Direction Trade</div><div id="trade-direction" class="signal-value"></div></div>
      <div class="signal-row"><div class="signal-label">Entrée</div><div id="trade-entry" class="signal-value"></div></div>
      <div class="signal-row"><div class="signal-label">Stop Loss</div><div id="trade-sl" class="signal-value red"></div></div>
      <div class="signal-row"><div class="signal-label">Take Profit 1 (1:1)</div><div id="trade-tp1" class="signal-value"></div></div>
      <div class="signal-row"><div class="signal-label">Take Profit 2 (Pool Liquidité)</div><div id="trade-tp2" class="signal-value"></div></div>
    </div>
  </div>

  <script>
    // Références DOM
    const priceEl = document.getElementById('price');
    const statusEl = document.getElementById('status');
    const smcLog = document.getElementById('smc-log');
    const signalPanel = document.getElementById('signal-panel');
    const trendEl = document.getElementById('trend-m15');
    const sweepTypeEl = document.getElementById('sweep-type');
    const sweepPriceEl = document.getElementById('sweep-price');
    const tradeDirectionEl = document.getElementById('trade-direction');
    const tradeEntryEl = document.getElementById('trade-entry');
    const tradeSLEl = document.getElementById('trade-sl');
    const tradeTP1El = document.getElementById('trade-tp1');
    const tradeTP2El = document.getElementById('trade-tp2');

    // Buffers de candles pour M1 et M15
    let candlesM1 = [];
    let candlesM15 = [];

    const symbol = 'BTCUSDT_UMCBL'; // Contrat futures USDT Bitget

    // ajout d'une entrée dans le log SMC
    function logSMC(msg) {
      const now = new Date().toLocaleTimeString();
      smcLog.textContent += `[${now}] ${msg}\n`;
      smcLog.scrollTop = smcLog.scrollHeight;
    }

    // ajout de chandelier (garde max 100)
    function addCandle(buffer, candle) {
      buffer.push(candle);
      if (buffer.length > 100) buffer.shift();
    }

    // Structure M15 (HH, HL, LL, LH)
    function getStructureM15(candles) {
      let structure = [];
      for (let i = 1; i < candles.length; i++) {
        const prev = candles[i -1];
        const curr = candles[i];
        if (curr.high > prev.high && curr.low > prev.low) structure.push('HH');
        else if (curr.low > prev.low && curr.high < prev.high) structure.push('HL');
        else if (curr.high < prev.high && curr.low < prev.low) structure.push('LL');
        else if (curr.high < prev.high && curr.low > prev.low) structure.push('LH');
        else structure.push('N');
      }
      return structure;
    }

    // Détecter tendance M15
    function detectTrendM15(candles) {
      const struct = getStructureM15(candles);
      if (struct.length < 3) return 'neutre';

      const last = struct[struct.length -1];
      const prev1 = struct[struct.length -2];
      const prev2 = struct[struct.length -3];

      if (prev2 === 'HL' && prev1 === 'HH' && last === 'HH') return 'bullish';
      if (prev2 === 'LH' && prev1 === 'LL' && last === 'LL') return 'bearish';
      if (last === 'HL' && prev1 === 'LH') return 'bullish';
      if (last === 'LH' && prev1 === 'HL') return 'bearish';

      return 'neutre';
    }

    // Détection sweep M1
    function detectSweep(candles, lookback=5) {
      if (candles.length < lookback+1) return [null,null];
      const lastCandle = candles[candles.length -1];
      const highs = candles.slice(candles.length - lookback -1, candles.length -1).map(c => c.high);
      const lows = candles.slice(candles.length - lookback -1, candles.length -1).map(c => c.low);

      if (lastCandle.high > Math.max(...highs)) return ['buy-side', lastCandle.high];
      if (lastCandle.low < Math.min(...lows)) return ['sell-side', lastCandle.low];
      return [null,null];
    }

    // Détection pool liquidité
    function detectLiquidityPool(candles, direction, lookback=20){
      const highs = candles.slice(-lookback-1, -1).map(c => c.high);
      const lows = candles.slice(-lookback-1, -1).map(c => c.low);
      if (direction === 'short') return Math.min(...lows);
      else return Math.max(...highs);
    }

    // Calcul niveaux trade
    function calcTradeParams(direction, sweepPrice, obPrice, poolPrice, riskPct=0.5, rrRatio=1){
      const slBuffer = sweepPrice * (riskPct / 100);
      let sl, tp1;
      if (direction === 'short') {
        sl = sweepPrice + slBuffer;
        tp1 = obPrice - (sl - obPrice) * rrRatio;
      } else if (direction === 'long') {
        sl = sweepPrice - slBuffer;
        tp1 = obPrice + (obPrice - sl) * rrRatio;
      } else {
        throw "Direction doit être 'long' ou 'short'";
      }
      return {
        entry: obPrice.toFixed(2),
        sl: sl.toFixed(2),
        tp1: tp1.toFixed(2),
        tp2: poolPrice.toFixed(2),
      };
    }

    // Connexion WebSocket Bitget
    const ws = new WebSocket('wss://ws.bitget.com/mix/v1/stream');

    ws.onopen = () => {
      statusEl.textContent = "Connecté au flux live Bitget";

      ws.send(JSON.stringify({
        op: "subscribe",
        args: [{
          instType: "mc",
          channel: "ticker",
          instId: symbol
        }]
      }));
      ws.send(JSON.stringify({
        op: "subscribe",
        args: [{
          instType: "mc",
          channel: "candle1m",
          instId: symbol
        }]
      }));
      ws.send(JSON.stringify({
        op: "subscribe",
        args: [{
          instType: "mc",
          channel: "candle15m",
          instId: symbol
        }]
      }));
    };

    ws.onmessage = (event) => {
      let msg;
      try {
        msg = JSON.parse(event.data);
      } catch(e) {
        console.error("Données WebSocket invalides:", e);
        return;
      }

      if (msg.arg && msg.data && msg.data.length) {
        const ch = msg.arg.channel;
        if (ch === 'ticker') {
          const last = parseFloat(msg.data[0].last);
          priceEl.textContent = last ? last.toFixed(2) + ' $' : '—';
        } else if (ch === 'candle1m') {
          const c = msg.data[0];
          const candle = {
            timestamp: c[0],
            open: parseFloat(c[1]),
            high: parseFloat(c[2]),
            low: parseFloat(c[3]),
            close: parseFloat(c[4]),
            volume: parseFloat(c[5])
          };
          addCandle(candlesM1, candle);

          // Détection sweep M1
          const [sweepType, sweepPrice] = detectSweep(candlesM1);
          sweepTypeEl.textContent = sweepType ? sweepType : '—';
          sweepPriceEl.textContent = sweepPrice ? sweepPrice.toFixed(2) : '—';

          // Log si sweep détecté
          if (sweepType) {
            logSMC(`Sweep détecté M1 : ${sweepType} à ${sweepPrice.toFixed(2)}`);
          }
        } else if (ch === 'candle15m') {
          const c = msg.data[0];
          const candle = {
            timestamp: c[0],
            open: parseFloat(c[1]),
            high: parseFloat(c[2]),
            low: parseFloat(c[3]),
            close: parseFloat(c[4]),
            volume: parseFloat(c[5])
          };
          addCandle(candlesM15, candle);

          // Détection tendance M15
          const trend = detectTrendM15(candlesM15);
          trendEl.textContent = trend.toUpperCase();
          trendEl.style.color = trend === 'bullish' ? '#66ff66' : (trend === 'bearish' ? '#ff6666' : '#aaa');

          // Log tendance
          if (trend === 'bullish' || trend === 'bearish') {
            logSMC(`Tendance M15 détectée : ${trend.toUpperCase()}`);
          }

          // Tentative de signal trade basé sur trend + sweep
          const [sweepType, sweepPrice] = detectSweep(candlesM1);

          if (!sweepType) {
            signalPanel.style.display = 'none';
            return;
          }

          let direction = null;
          if (trend === 'bullish' && sweepType === 'sell-side') direction = 'long';
          else if (trend === 'bearish' && sweepType === 'buy-side') direction = 'short';

          if (!direction) {
            signalPanel.style.display = 'none';
            return;
          }

          const obPrice = candlesM1.length > 0 ? candlesM1[candlesM1.length-1].close : null;
          if (!obPrice) {
            signalPanel.style.display = 'none';
            return;
          }

          // Calcul pool liquidité
          const poolPrice = detectLiquidityPool(candlesM1, direction);

          // Calcul niveaux trade
          const levels = calcTradeParams(direction, sweepPrice, obPrice, poolPrice, 0.5, 1);

          tradeDirectionEl.textContent = direction.toUpperCase();
          tradeEntryEl.textContent = levels.entry;
          tradeSLEl.textContent = levels.sl;
          tradeTP1El.textContent = levels.tp1;
          tradeTP2El.textContent = levels.tp2;

          signalPanel.style.display = 'block';
          logSMC(`Signal Trade : Direction ${direction.toUpperCase()}, Entrée ${levels.entry}, SL ${levels.sl}, TP1 ${levels.tp1}, TP2 ${levels.tp2}`);
        }
      }
    };

    ws.onerror = () => {
      statusEl.textContent = "Erreur WebSocket. Vérifiez la connexion.";
      priceEl.textContent = "Erreur prix";
    };

    ws.onclose = () => {
      statusEl.textContent = "Déconnecté du flux live. Rafraîchissez la page.";
      priceEl.textContent = "--";
      signalPanel.style.display = 'none';
    };
  </script>

</body>
</html>
