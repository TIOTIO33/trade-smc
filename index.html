<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Bot SMC BTC/USDT Prix en Direct - Bitget</title>
  <style>
    body {
      background: #111;
      color: #eee;
      font-family: Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      margin: 0;
      padding: 20px;
    }
    .container {
      background: #222;
      border-radius: 8px;
      padding: 25px 40px;
      box-shadow: 0 2px 12px #000;
      max-width: 600px;
      width: 100%;
    }
    h1 {
      font-weight: 700;
      margin-bottom: 18px;
      color: #33ff66;
      text-align: center;
    }
    #price {
      font-size: 3em;
      font-weight: 700;
      text-align: center;
      margin-bottom: 15px;
      color: #33ff66;
      font-feature-settings: "tnum";
      font-variant-numeric: tabular-nums;
    }
    #status {
      color: orange;
      text-align: center;
      font-size: 1.1em;
      margin-bottom: 30px;
    }
    #smc-log {
      background: #111;
      border: 1px solid #333;
      padding: 15px;
      height: 250px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 14px;
      white-space: pre-wrap;
      border-radius: 6px;
    }
  </style>
</head>
<body>

  <div class="container">
    <h1>Bot SMC BTC/USDT <br> Prix en Direct (Bitget)</h1>
    <div id="price">Chargement...</div>
    <div id="status">Connexion au flux WebSocket ...</div>

    <!-- Zone de log pour afficher la logique et signaux SMC -->
    <div id="smc-log">Logs SMC en temps réel...</div>
  </div>

  <script>
    // Références DOM
    const priceEl = document.getElementById('price');
    const statusEl = document.getElementById('status');
    const smcLog = document.getElementById('smc-log');

    // Buffer de candles M1 et M15 pour ta logique
    let candlesM1 = [];
    let candlesM15 = [];

    // Configuration
    const symbol = 'BTCUSDT_UMCBL'; // Contrat futures USDT sur Bitget

    // Fonction pour ajouter log dans la zone SMC
    function logSMC(msg) {
      const now = new Date().toLocaleTimeString();
      smcLog.textContent += `[${now}] ${msg}\n`;
      smcLog.scrollTop = smcLog.scrollHeight;
    }

    // Simulation simple des candles (à compléter avec ta logique complète)
    function addCandle(candles, candle) {
      candles.push(candle);
      if (candles.length > 100) candles.shift();
    }

    // Exemple simple de détection sweep sur candle M1 (exemple basique)
    function detectSweep(candles) {
      if (candles.length < 6) return null;
      const lastCandle = candles[candles.length -1];
      const highs = candles.slice(-6, -1).map(c => c.high);
      const lows = candles.slice(-6, -1).map(c => c.low);
      if (lastCandle.high > Math.max(...highs)) return {type:'buy-side', price: lastCandle.high};
      if (lastCandle.low < Math.min(...lows)) return {type:'sell-side', price: lastCandle.low};
      return null;
    }

    // Connexion WebSocket Bitget
    const ws = new WebSocket('wss://ws.bitget.com/mix/v1/stream');

    ws.onopen = () => {
      statusEl.textContent = "Connecté au flux live Bitget";

      // Souscrire au ticker 1s BTCUSDT_UMCBL
      ws.send(JSON.stringify({
        op: "subscribe",
        args: [{
          instType: "mc",
          channel: "ticker",
          instId: symbol
        }]
      }));

      // Souscrire au candles 1m (exemple)
      ws.send(JSON.stringify({
        op: "subscribe",
        args: [{
          instType: "mc",
          channel: "candle1m",
          instId: symbol
        }]
      }));

      // Souscrire aux candles 15m (exemple)
      ws.send(JSON.stringify({
        op: "subscribe",
        args: [{
          instType: "mc",
          channel: "candle15m",
          instId: symbol
        }]
      }));
    };

    ws.onmessage = (event) => {
      let msg;
      try {
        msg = JSON.parse(event.data);
      } catch(e) {
        console.error("Données WebSocket invalides:", e);
        return;
      }

      if (msg.arg && msg.data && msg.data.length) {
        const ch = msg.arg.channel;

        // Prix en direct depuis le ticker
        if (ch === 'ticker') {
          const last = parseFloat(msg.data[0].last);
          priceEl.textContent = last ? last.toFixed(2) + ' $' : '—';
        }

        // Gestion des candles 1m
        else if (ch === 'candle1m') {
          const candleRaw = msg.data[0];
          // candleRaw structure: [ts, open, high, low, close, vol, ...]
          const candle = {
            timestamp: candleRaw[0],
            open: parseFloat(candleRaw[1]),
            high: parseFloat(candleRaw[2]),
            low: parseFloat(candleRaw[3]),
            close: parseFloat(candleRaw[4]),
            volume: parseFloat(candleRaw[5])
          };
          addCandle(candlesM1, candle);

          // Exemple: détection sweep M1
          const sweep = detectSweep(candlesM1);
          if (sweep) {
            logSMC(`Sweep détecté M1 : ${sweep.type} à ${sweep.price.toFixed(2)}`);
          }
        }

        // Gestion des candles 15m
        else if (ch === 'candle15m') {
          const candleRaw = msg.data[0];
          const candle = {
            timestamp: candleRaw[0],
            open: parseFloat(candleRaw[1]),
            high: parseFloat(candleRaw[2]),
            low: parseFloat(candleRaw[3]),
            close: parseFloat(candleRaw[4]),
            volume: parseFloat(candleRaw[5])
          };
          addCandle(candlesM15, candle);

          // Ici, tu peux faire ta détection de structure M15, trend, etc.
          // Exemple simple (à enrichir):
          if (candlesM15.length > 2) {
            logSMC(`Candle M15 ajoutée - Close: ${candle.close.toFixed(2)}`);
          }
        }
      }
    };

    ws.onerror = () => {
      statusEl.textContent = "Erreur WebSocket. Vérifiez la connexion.";
      priceEl.textContent = "Erreur prix";
    };

    ws.onclose = () => {
      statusEl.textContent = "Déconnecté du flux live. Rafraîchissez la page.";
      priceEl.textContent = "--";
    };
  </script>

</body>
</html>
